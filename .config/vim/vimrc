set nocompatible                " Disable vi compatiblity

"===================
"=== XDG SUPPORT ===
"===================
if empty($MYVIMRC) | let $MYVIMRC = expand('<sfile>:p') | endif

set runtimepath^=$XDG_CONFIG_HOME/vim
set runtimepath+=$XDG_DATA_HOME/vim
set runtimepath+=$XDG_CONFIG_HOME/vim/after

set packpath^=$XDG_DATA_HOME/vim,$XDG_CONFIG_HOME/vim
set packpath+=$XDG_CONFIG_HOME/vim/after,$XDG_DATA_HOME/vim/after

let g:netrw_home = $XDG_DATA_HOME."/vim"
call mkdir($XDG_DATA_HOME."/vim/spell", 'p', 0700)
set viewdir=$XDG_DATA_HOME/vim/view | call mkdir(&viewdir, 'p', 0700)

set backupdir=$XDG_CACHE_HOME/vim/backup | call mkdir(&backupdir, 'p', 0700)
set directory=$XDG_CACHE_HOME/vim/swap   | call mkdir(&directory, 'p', 0700)
set undodir=$XDG_CACHE_HOME/vim/undo     | call mkdir(&undodir,   'p', 0700)

if !has('nvim') | set viminfofile=$XDG_CACHE_HOME/vim/viminfo | endif

"================
"=== vim-plug ===
"================

" Automatically install vimplug if not installed
let data_dir = '$XDG_CONFIG_HOME/vim'
if empty(glob(data_dir . '/autoload/plug.vim'))
	silent execute '!curl -fLo '.data_dir.'/autoload/plug.vim --create-dirs https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim'
	autocmd VimEnter * PlugInstall --sync | source $MYVIMRC
endif

call plug#begin('$XDG_DATA_HOME/vim/plugged')
Plug 'sheerun/vim-polyglot'
Plug 'prabirshrestha/vim-lsp'
Plug 'mattn/vim-lsp-settings'
Plug 'prabirshrestha/asyncomplete.vim'
Plug 'prabirshrestha/asyncomplete-lsp.vim'
Plug 'vim-scripts/dbext.vim'
Plug 'elkowar/yuck.vim'
Plug 'dracula/vim', { 'as' : 'dracula' }
Plug 'itchyny/vim-cursorword'
Plug 'junegunn/goyo.vim'
Plug 'Konfekt/FastFold'
Plug 'itchyny/lightline.vim'
Plug 'justinmk/vim-dirvish'
Plug 'Donaldttt/fuzzyy', { 'branch': 'vim8' }
Plug 'EgZvor/vim-ostroga'
Plug 'rhysd/clever-f.vim'
" Text operations/manipulation
Plug 'wellle/targets.vim'
Plug 'justinmk/vim-sneak'
Plug 'tpope/vim-surround'
Plug 'tpope/vim-speeddating'
Plug 'tpope/vim-repeat'
Plug 'tommcdo/vim-lion'
Plug 'tommcdo/vim-exchange'
Plug 'mbbill/undotree'
Plug 'tomtom/tcomment_vim'
Plug 'mattn/emmet-vim', { 'for': [ 'html', 'css', 'php', 'javascript' ] }
Plug 'preservim/vim-pencil'
call plug#end()

"================
"=== Settings ===
"================
" If you want to know what each setting does you can do :h <setting name>

let loaded_netrw = 1
let loaded_netrwPlugin = 1      "netrw -> ðŸ—‘

set clipboard=unnamedplus " for x11 systems
nnoremap <C-p> :r!wl-paste<CR>
xnoremap <silent> <C-y> :w !wl-copy<CR><CR>

set hidden

set scrolloff=9 sidescrolloff=9

set shortmess=a
set title
set relativenumber

" Search
set ignorecase smartcase
if has('extra_search')
	set nohlsearch incsearch
endif

if has('cmdline_info')
	set ruler showcmd
endif

" Spelling correction
if has('syntax')
	syntax on
	set nospell
	set spelllang=fr
	set cursorline
endif

" set Vim-specific sequences for RGB colors and enable truecolor support
if $COLORTERM ==# "truecolor" && has('termguicolors')
	set termguicolors
	let &t_8f = "\<Esc>[38;2;%lu;%lu;%lum"
	let &t_8b = "\<Esc>[48;2;%lu;%lu;%lum"
endif

" Changes cursor shape in different modes
let &t_SI = "\<Esc>[6 q"
let &t_SR = "\<Esc>[4 q"
let &t_EI = "\<Esc>[2 q"

" Tab complete for fuzzy finding
if has('wildmenu')
	set wildmenu wildignorecase wildmode=longest:list,full
	if has('wildignore') && !($XDG_CURRENT_DESKTOP ==# "KDE") " School computer too old
		set wildoptions=pum
		set wildignore+=*.bmp,*.gif,*.ico,*.jpg,*.jpeg,*.jpe,*.png,*.webp,*.svg
		set wildignore+=*.pdf,*.psd,*.epub,*.ps,*.djvu,*.mobi
		set wildignore+=*.word,*.ods,*.docx,*.odt,*.doc,*.xlsx
		set wildignore+=*.wav,*.mp3,*.flac,*.opus,*.m3u,*.ogg
		set wildignore+=*.mp4,*.mkv,*.webm,*.m4a
		set wildignore+=*.o,*.obj,*.out
		set wildignore+=*/,
		set wildignore+=node_modules/*,bower_components/*
	endif
endif

" Code safety
if has('persistent_undo')       " You can undo changes across sessions
	set undolevels=5000
	set autowriteall undofile autoread
else
	echom "Your system doesn't support persistent undo ! Be careful !"
endif
set updatecount=10

" Folds
if has('folding')
	"Let the lsp handle folding
	set foldmethod=expr
				\ foldexpr=lsp#ui#vim#folding#foldexpr()
				\ foldtext=lsp#ui#vim#folding#foldtext()

	set foldnestmax=1
	set foldlevelstart=20
	set foldminlines=0

	" Toggle overview mode (close or open all folds)
	" Mapped to <leader>o (look at mappings)
	function ToggleOverview()
		if &foldlevel > 0
			let b:tmp = &foldlevel
			let &l:foldlevel = 0
		else
			let &l:foldlevel = b:tmp
		endif
	endfunction
endif

" Indentation
filetype plugin indent on
if has('smartindent')
	set autoindent smartindent
else
	set autoindent
endif

"-----------------------
"=== Plugin settings ===
"-----------------------

let g:lion_squeeze_spaces = 1

" Autocompletion with asynccomplete
set infercase
let g:asyncomplete_auto_completeopt = 0
set completeopt=menuone,noinsert,noselect,preview
autocmd! CompleteDone * if pumvisible() == 0 | pclose | endif
let g:asyncomplete_auto_popup = 0

function! s:check_back_space() abort
    let col = col('.') - 1
    return !col || getline('.')[col - 1]  =~ '\s'
endfunction

inoremap <silent><expr> <TAB>
  \ pumvisible() ? "\<C-n>" :
  \ <SID>check_back_space() ? "\<TAB>" :
  \ asyncomplete#force_refresh()
inoremap <expr><S-TAB> pumvisible() ? "\<C-p>" : "\<C-h>"

" Lightline
set laststatus=2
set noshowmode
let g:lightline = {
	\ 'colorscheme':  'dracula',
	\ 'active': {
	\   'left': [ [ 'mode', 'paste' ], [ 'readonly', 'filename', 'modified' ] ]
	\ },
	\ }

" highlight column 81 in gray
call matchadd('ColorColumn', '\%81v',100)
colorscheme dracula
hi Normal guibg=NONE ctermbg=NONE

" Dirvish file viewer
let g:dirvish_mode = 1
let g:dirvish_relative_paths = 0
call dirvish#add_icon_fn({p -> p[-1:]=='/'?'ðŸ“‚':'ðŸ“„'})

" Ostorga Jump forget marks
" Search upwards for a manually created .viminfo file or use a default
let &viminfofile=findfile('.viminfo','.;') ?? $XDG_CACHE_HOME . '/vim/viminfo'

"=======================
"=== Global Bindings ===
"=======================

let mapleader=" "

" Swap visual and visual-block
nnoremap v <C-V>
nnoremap <C-v> v

" Move stuff in visual mode (wow)
vnoremap J :m+1<CR>gv=gv
vnoremap K :m-2<CR>gv=gv

" Don't move cursor around
nnoremap J mzJ`z
nnoremap <C-d> <C-d>zz
nnoremap <C-u> <C-u>zz
nnoremap n nzzzv
nnoremap N Nzzzv

" Delete or paste without changing your yank buffer
xmap <leader>p "_dP
nmap <leader>d "_d
vmap <leader>d "_d

" Time savers
map <C-h> <C-w>h
map <C-j> <C-w>j
map <C-k> <C-w>k
map <C-l> <C-w>l
map <leader>q :close<CR>
map <leader>w :wa<CR>
map <leader>x :!chmod +x %<CR>
map <leader>cc :bd<CR>
noremap Q <nop>

" Substitute the word you're on
map <leader>s :%s/\<<C-r><C-w>\>/<C-r><C-w>/gI<Left><Left><Left>

" Fuzzy grep the word under the cursor
nnoremap <Space>f :FuzzyGrep <C-R><C-W><CR>

" Compile and run c++ file for classes
map <leader>m :!g++ -Wpedantic -O3 %:p -o %:p:r.out && %:p:r.out<CR>

" Convert camel_case to snake_case
command -range SnakeCase <line1>,<line2>s#\(\<\u\l\+\|\l\+\)\(\u\)#\l\1_\l\2#g
map <leader>sk :SnakeCase<CR>:noh<CR>
command -range CamelCase <line1>,<line2>s/\(_\)\(.\)/\u\2/g
map <leader>ck :CamelCase<CR>:noh<CR>

" Harpoon from wish
nnoremap <leader><leader> <cmd>OstrogaJump<cr>

" lsp
function! s:on_lsp_buffer_enabled() abort
    setlocal omnifunc=lsp#complete
    setlocal signcolumn=yes
    if exists('+tagfunc') | setlocal tagfunc=lsp#tagfunc | endif
    nmap <buffer> gd <plug>(lsp-definition)
    nmap <buffer> gs <plug>(lsp-document-symbol-search)
    nmap <buffer> gS <plug>(lsp-workspace-symbol-search)
    nmap <buffer> gr <plug>(lsp-references)
    nmap <buffer> gi <plug>(lsp-implementation)
    nmap <buffer> gt <plug>(lsp-type-definition)
    nmap <buffer> <leader>rn <plug>(lsp-rename)
    nmap <buffer> [g <plug>(lsp-previous-diagnostic)
    nmap <buffer> ]g <plug>(lsp-next-diagnostic)
    nmap <buffer> K <plug>(lsp-hover)
    nnoremap <buffer> <expr><c-f> lsp#scroll(+4)
    nnoremap <buffer> <expr><c-d> lsp#scroll(-4)

    let g:lsp_format_sync_timeout = 1000
    autocmd! BufWritePre *.rs,*.go call execute('LspDocumentFormatSync')

    " refer to doc to add more commands
endfunction

" --
" TOGGLES
" --

" undotree
map <leader>u :UndotreeToggle<CR>

" Look at folding settings
map <silent> <leader>o :call ToggleOverview()<CR>

" Toggle ro to avoid editing a file
map <leader>r :call ToggleReadonly()<CR>
function ToggleReadonly()
	if &readonly == 1
		let &readonly=0
	else
		let &readonly=1
	endif
endfunction

" (centered text plugin)
map <leader>g :Goyo<CR>:set relativenumber<CR>

"====================================================
"=== Some autoexec commands and filetype bindings ===
"====================================================

if has('autocmd')
	autocmd FileType tex,latex,markdown setlocal spell! | setlocal fp="fmt -w80"

	autocmd FileType python,sh set foldmethod=indent

	autocmd BufNewFile,BufRead * if empty(&filetype) | setlocal fp="fmt -w80" | endif

	autocmd BufWritePre *.sql silent %s/\<\w\+\>/\=synIDattr(synID(line('.'),col('.'),1), 'name')=~?'sql\%(keyword\|operator\|statement\|type\|function\)'?toupper(submatch(0)):submatch(0)/g |''

	autocmd BufWritePre * %s/\s\+$//e " Remove trailing spaces

else
	echom "This build does not support autocmds"

	augroup pencil
	  autocmd!
	  autocmd FileType markdown,mkd call pencil#init()
	  autocmd FileType text         call pencil#init() | execute silent :Goyo<CR>
	augroup END
endif
